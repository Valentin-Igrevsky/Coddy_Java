```java
import java.util.Scanner;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        Game game = new Game();
        game.start();
    }
}

class Game {
    private final Scanner scanner = new Scanner(System.in);
    private Board board;
    public boolean gameOver;
    public boolean gameWon;

    void start() {
        System.out.println("Добро пожаловать в Сапер!");

        // Выбор сложности
        System.out.println("Выберите уровень сложности:");
        System.out.println("1. Новичок (8x8, 10 мин)");
        System.out.println("2. Любитель (12x12, 20 мин)");
        System.out.println("3. Профессионал (16x16, 40 мин)");

        int choice = -1;
        while (choice < 1 || choice > 3) {
            choice = scanner.nextInt();
            switch (choice) {
                case 1:
                    board = new Board(8, 8, 10);
                    break;
                case 2:
                    board = new Board(12, 12, 20);
                    break;
                case 3:
                    board = new Board(16, 16, 40);
                    break;
            }
        }

        gameOver = false;
        gameWon = false;

        board.placeMines();
        board.placeNums();

        while (!gameOver && !gameWon) {
            clearScreen();
            printGameState();

            System.out.println("\nКоманды:");
            System.out.println("1. Открыть клетку (формат: o строка столбец)");
            System.out.println("2. Поставить/убрать флажок (формат: f строка столбец)");
            System.out.println("3. Выход из игры (формат: q)");

            System.out.print("\nВведите команду: ");
            String input = scanner.nextLine().trim();

            if (input.equalsIgnoreCase("q")) {
                System.out.println("Игра завершена.");
                return;
            }

            String[] parts = input.split(" ");
            if (parts.length != 3) {
                System.out.println("Неверный формат команды.");
                continue;
            }

            String command = parts[0];
            int row, col;

            row = Integer.parseInt(parts[1]) - 1;
            col = Integer.parseInt(parts[2]) - 1;

            if (!board.inBounds(row, col)) {
                System.out.println("Координаты вне игрового поля. Нажмите Enter чтобы продолжить...");
                continue;
            }

            if (command.equalsIgnoreCase("o")) {
                openCellResult ocr = board.openCell(row, col);
                switch (ocr) {
                    case openCellResult.isFlagged -> System.out.println("Клетка помечена флажком. Сначала уберите флажок.");
                    case openCellResult.isOpened -> System.out.println("Клетка уже открыта.");
                    case openCellResult.hasOpened -> System.out.println("Клетка открыта");
                    case openCellResult.hasMine -> gameOver = true;

                }

            } else if (command.equalsIgnoreCase("f")) {
                toggleFlagResult tfr = board.toggleFlag(row, col);
                switch (tfr) {
                    case toggleFlagResult.isOpened -> System.out.println("Нельзя поставить флаг на открытую клетку.");
                    case toggleFlagResult.unsetFlag -> System.out.println("Флаг снят.");
                    case toggleFlagResult.setFlag -> System.out.println("Флаг установлен.");
                    case toggleFlagResult.notEnoughFlags -> System.out.println("Вы использовали все флажки!");
                }
            }

            gameWon = board.checkWinCondition();
        }

        clearScreen();
        board.revealAll();
        printGameState();

        if (gameWon) {
            System.out.println("\nПОЗДРАВЛЯЕМ! Вы выиграли!");
        } else {
            System.out.println("\nИГРА ОКОНЧЕНА! Вы наступили на мину!");
        }
    }

    private void printGameState() {
        System.out.println("\n=== САПЕР ===");
        System.out.println("Мины: " + board.minesCount + "  Флажки: " + board.flagsCount + "/" + board.minesCount);
        System.out.println();

        board.print();
    }

    private void clearScreen() {
        for (int i = 0; i < 30; i++) {
            System.out.println();
        }
    }
}

class Board {
    public final int rows;
    public final int cols;
    public final int minesCount;
    public int flagsCount;
    public final Cell[][] board;
    private final Random random = new Random();

    public Board(int rows, int cols, int minesCount) {
        this.rows = rows;
        this.cols = cols;
        this.minesCount = minesCount;
        this.flagsCount = 0;
        this.board = new Cell[rows][cols];

        for (int y = 0; y < rows; y++) {
            for (int x = 0; x < cols; x++) {
                board[y][x] = new Cell();
            }
        }
    }

    public void placeMines() {
        int placed = 0;

        while (placed < this.minesCount) {
            int row = random.nextInt(rows);
            int col = random.nextInt(cols);

            Cell cell = board[row][col];
            if (!cell.hasMine) {
                cell.hasMine = true;
                placed++;
            }
        }
    }

    private int countMines(int x, int y) {
        int count = 0;
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                if (dx == 0 && dy == 0) continue;

                int nx = x + dx;
                int ny = y + dy;

                if (!inBounds(ny, nx)) continue;

                Cell neighbor = board[ny][nx];
                if (neighbor.hasMine) count++;
            }
        }
        return count;
    }

    public void placeNums() {
        for (int y = 0; y < rows; y++) {
            for (int x = 0; x < cols; x++) {
                if (board[y][x].hasMine) continue;
                board[y][x].minesCount = countMines(x, y);
            }
        }
    }

    private void openAdjacentCells(int row, int col) {
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr == 0 && dc == 0) continue;

                int nr = row + dr;
                int nc = col + dc;

                if (inBounds(nr, nc)) {
                    Cell neighbor = board[nr][nc];
                    if (!neighbor.isOpened && !neighbor.isFlagged && !neighbor.hasMine) {
                        neighbor.isOpened = true;
                        if (neighbor.minesCount == 0) {
                            openAdjacentCells(nr, nc);
                        }
                    }
                }
            }
        }
    }

    public openCellResult openCell(int row, int col) {
        Cell cell = board[row][col];

        if (cell.isFlagged) {
            return openCellResult.isFlagged;
        }

        if (cell.isOpened) {
            return openCellResult.isOpened;
        }

        cell.isOpened = true;

        if (cell.hasMine) {
            return openCellResult.hasMine;
        }

        if (cell.minesCount == 0) {
            openAdjacentCells(row, col);
        }

        return openCellResult.hasOpened;
    }

    public toggleFlagResult toggleFlag(int row, int col) {
        Cell cell = board[row][col];

        if (cell.isOpened) {
            return toggleFlagResult.isOpened;
        }

        if (cell.isFlagged) {
            cell.isFlagged = false;
            this.flagsCount--;
            return toggleFlagResult.unsetFlag;
        } else {
            if (this.flagsCount >= this.minesCount) {
                System.out.println("Вы использовали все флажки!");
                return toggleFlagResult.notEnoughFlags;
            }
            cell.isFlagged = true;
            flagsCount++;
            return toggleFlagResult.setFlag;
        }
    }

    public boolean checkWinCondition() {
        int correctFlags = 0;
        int correctlyOpened = 0;

        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                Cell cell = board[r][c];

                if (cell.hasMine && cell.isFlagged) {
                    correctFlags++;
                }

                if (!cell.hasMine && cell.isOpened) {
                    correctlyOpened++;
                }
            }
        }

        int totalNonMineCells = rows * cols - minesCount;
        if (correctFlags == minesCount && correctlyOpened == totalNonMineCells) {
            return true;
        }
        return false;
    }

    public boolean inBounds(int row, int col) {
        return row >= 0 && row < rows && col >= 0 && col < cols;
    }

    public void print() {
        System.out.print("   ");
        for (int c = 0; c < cols; c++) {
            System.out.printf("%2d ", c + 1);
        }
        System.out.println();

        System.out.print("   ");
        for (int c = 0; c < cols; c++) {
            System.out.print("---");
        }
        System.out.println();

        for (int r = 0; r < rows; r++) {
            System.out.printf("%2d|", r + 1);
            for (int c = 0; c < cols; c++) {
                System.out.print(" " + board[r][c].getDisplayChar() + " ");
            }
            System.out.println();
        }
    }

    public void revealAll() {
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                board[r][c].isOpened = true;
            }
        }
    }
}

class Cell {
    public boolean hasMine;
    public boolean isOpened;
    public boolean isFlagged;
    public int minesCount;

    public Cell() {
        this.hasMine = false;
        this.isOpened = false;
        this.isFlagged = false;
        this.minesCount = 0;
    }

    public char getDisplayChar() {
        if (isFlagged) return 'F';
        if (!isOpened) return '.';
        if (hasMine) return '*';
        if (minesCount == 0) return ' ';
        return (char) ('0' + minesCount);
    }
}

enum toggleFlagResult {isOpened, setFlag, unsetFlag, notEnoughFlags}
enum openCellResult {isFlagged, isOpened, hasOpened, hasMine}
```